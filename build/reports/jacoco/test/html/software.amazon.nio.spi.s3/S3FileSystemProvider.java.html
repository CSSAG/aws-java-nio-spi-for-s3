<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>S3FileSystemProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s3fs-spi</a> &gt; <a href="index.source.html" class="el_package">software.amazon.nio.spi.s3</a> &gt; <span class="el_source">S3FileSystemProvider.java</span></div><h1>S3FileSystemProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package software.amazon.nio.spi.s3;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import software.amazon.awssdk.http.SdkHttpResponse;
import software.amazon.awssdk.services.s3.S3AsyncClient;
import software.amazon.awssdk.services.s3.model.S3Object;
import software.amazon.awssdk.services.s3.model.S3Response;
import software.amazon.nio.spi.s3.util.TimeOutUtils;

import java.io.IOException;
import java.net.URI;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.FileAttributeView;
import java.nio.file.spi.FileSystemProvider;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;

import static java.nio.file.LinkOption.NOFOLLOW_LINKS;
import static java.util.concurrent.TimeUnit.MINUTES;
import static software.amazon.awssdk.http.HttpStatusCode.FORBIDDEN;
import static software.amazon.awssdk.http.HttpStatusCode.NOT_FOUND;
import static software.amazon.nio.spi.s3.util.TimeOutUtils.TIMEOUT_TIME_LENGTH_1;
import static software.amazon.nio.spi.s3.util.TimeOutUtils.logAndGenerateExceptionOnTimeOut;

/**
 * Service-provider class for S3 when represented as an NIO filesystem. The methods defined by the Files class will
 * delegate to an instance of this class when referring to an object in S3. This class will in turn make calls to the
 * S3 service.
 *
 * This class should never be used directly. It is invoked by the service loader when, for example, the java.nio.file.Files
 * class is used to address an object beginning with the scheme &quot;s3&quot;.
 */
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">public class S3FileSystemProvider extends FileSystemProvider {</span>

    public static final String SCHEME = &quot;s3&quot;;

<span class="fc" id="L51">    Logger logger = LoggerFactory.getLogger(this.getClass().getName());</span>

    /**
     * Returns the URI scheme that identifies this provider.
     *
     * @return The URI scheme (s3)
     */
    @Override
    public String getScheme() {
<span class="fc" id="L60">        return SCHEME;</span>
    }

    /**
     * Constructs a new {@code FileSystem} object identified by a URI. This
     * method is invoked by the {@link FileSystems#newFileSystem(URI, Map)}
     * method to open a new file system identified by a URI.
     *
     * &lt;p&gt; The {@code uri} parameter is an absolute, hierarchical URI, with a
     * scheme equal (without regard to case) to the scheme supported by this
     * provider. The exact form of the URI is highly provider dependent. The
     * {@code env} parameter is a map of provider specific properties to configure
     * the file system.
     *
     * &lt;p&gt; This method throws {@link FileSystemAlreadyExistsException} if the
     * file system already exists because it was previously created by an
     * invocation of this method. Once a file system is {@link
     * FileSystem#close closed} it is provider-dependent if the
     * provider allows a new file system to be created with the same URI as a
     * file system it previously created.
     *
     * @param uri URI reference
     * @param env A map of provider specific properties to configure the file system;
     *            may be empty
     * @return A new file system
     */
    @Override
    public FileSystem newFileSystem(URI uri, Map&lt;String, ?&gt; env) {
<span class="fc" id="L88">        return new S3FileSystem(uri, this);</span>
    }

    /**
     * Returns an existing {@code FileSystem} created by this provider.
     *
     * &lt;p&gt; This method returns a reference to a {@code FileSystem} that was
     * created by invoking the {@link #newFileSystem(URI, Map) newFileSystem(URI,Map)}
     * method. File systems created the {@link #newFileSystem(Path, Map)
     * newFileSystem(Path,Map)} method are not returned by this method.
     * The file system is identified by its {@code URI}. Its exact form
     * is highly provider dependent. In the case of the default provider the URI's
     * path component is {@code &quot;/&quot;} and the authority, query and fragment components
     * are undefined (Undefined components are represented by {@code null}).
     *
     * &lt;p&gt; Once a file system created by this provider is {@link
     * FileSystem#close closed} it is provider-dependent if this
     * method returns a reference to the closed file system or throws {@link
     * FileSystemNotFoundException}. If the provider allows a new file system to
     * be created with the same URI as a file system it previously created then
     * this method throws the exception if invoked after the file system is
     * closed (and before a new instance is created by the {@link #newFileSystem
     * newFileSystem} method).
     *
     * &lt;p&gt; If a security manager is installed then a provider implementation
     * may require to check a permission before returning a reference to an
     * existing file system. In the case of the {@link FileSystems#getDefault
     * default} file system, no permission check is required.
     *
     * @param uri URI reference
     * @return The file system
     * @throws IllegalArgumentException    If the pre-conditions for the {@code uri} parameter aren't met
     * @throws FileSystemNotFoundException If the file system does not exist
     * @throws SecurityException           If a security manager is installed, and it denies an unspecified
     *                                     permission.
     */
    @Override
    public S3FileSystem getFileSystem(URI uri) {
<span class="fc" id="L126">        return new S3FileSystem(uri, this);</span>
    }

    /**
     * Return a {@code Path} object by converting the given {@link URI}. The
     * resulting {@code Path} is associated with a {@link FileSystem} that
     * already exists or is constructed automatically.
     *
     * &lt;p&gt; The exact form of the URI is file system provider dependent. In the
     * case of the default provider, the URI scheme is {@code &quot;file&quot;} and the
     * given URI has a non-empty path component, and undefined query, and
     * fragment components. The resulting {@code Path} is associated with the
     * default {@link FileSystems#getDefault default} {@code FileSystem}.
     *
     * &lt;p&gt; If a security manager is installed then a provider implementation
     * may require to check a permission. In the case of the {@link
     * FileSystems#getDefault default} file system, no permission check is
     * required.
     *
     * @param uri The URI to convert
     * @return The resulting {@code Path}
     * @throws IllegalArgumentException    If the URI scheme does not identify this provider or other
     *                                     preconditions on the uri parameter do not hold
     * @throws FileSystemNotFoundException The file system, identified by the URI, does not exist and
     *                                     cannot be created automatically
     * @throws SecurityException           If a security manager is installed, and it denies an unspecified
     *                                     permission.
     */
    @Override
    public S3Path getPath(URI uri) {
<span class="fc" id="L156">        Objects.requireNonNull(uri);</span>
<span class="fc" id="L157">        return ((S3FileSystem) FileSystems.getFileSystem(uri)).getPath(uri.getPath());</span>
    }

    /**
     * Opens or creates a file, returning a seekable byte channel to access the
     * file. This method works in exactly the manner specified by the {@link
     * Files#newByteChannel(Path, Set, FileAttribute[])} method.
     *
     * @param path    the path to the file to open or create
     * @param options options specifying how the file is opened
     * @param attrs   an optional list of file attributes to set atomically when
     *                creating the file
     * @return a new seekable byte channel
     * @throws IllegalArgumentException      if the set contains an invalid combination of options
     * @throws UnsupportedOperationException if an unsupported open option is specified or the array contains
     *                                       attributes that cannot be set atomically when creating the file
     * @throws FileAlreadyExistsException    if a file of that name already exists and the {@link
     *                                       StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified
     *                                       &lt;i&gt;(optional specific exception)&lt;/i&gt;
     * @throws IOException                   if an I/O error occurs
     * @throws SecurityException             In the case of the default provider, and a security manager is
     *                                       installed, the {@link SecurityManager#checkRead(String) checkRead}
     *                                       method is invoked to check read access to the path if the file is
     *                                       opened for reading. The {@link SecurityManager#checkWrite(String)
     *                                       checkWrite} method is invoked to check write access to the path
     *                                       if the file is opened for writing. The {@link
     *                                       SecurityManager#checkDelete(String) checkDelete} method is
     *                                       invoked to check delete access if the file is opened with the
     *                                       {@code DELETE_ON_CLOSE} option.
     */
    @Override
    public SeekableByteChannel newByteChannel(Path path, Set&lt;? extends OpenOption&gt; options, FileAttribute&lt;?&gt;... attrs) throws IOException {
<span class="nc" id="L189">        return this.newByteChannel(null, path, options, attrs);</span>
    }

    /**
     * Construct a byte channel for the path with the specified client. A more composable and testable (by using a Mock Client)
     * version of the public method
     */
    protected SeekableByteChannel newByteChannel(S3AsyncClient client, Path path, Set&lt;? extends OpenOption&gt; options, FileAttribute&lt;?&gt;... attrs) throws IOException {
<span class="fc" id="L197">        final S3Path s3Path = getPath(path.toUri());</span>
        final S3SeekableByteChannel channel;

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if(client == null){</span>
<span class="nc" id="L201">            channel = new S3SeekableByteChannel(s3Path);</span>
        } else {
<span class="fc" id="L203">            channel = new S3SeekableByteChannel(s3Path, client, 0L);</span>
        }
<span class="fc" id="L205">        s3Path.getFileSystem().registerOpenChannel(channel);</span>
<span class="fc" id="L206">        return channel;</span>
    }


    /**
     * Opens a directory, returning a {@code DirectoryStream} to iterate over
     * the entries in the directory. This method works in exactly the manner
     * specified by the {@link
     * Files#newDirectoryStream(Path, DirectoryStream.Filter)}
     * method.
     *
     * @param dir    the path to the directory
     * @param filter the directory stream filter
     * @return a new and open {@code DirectoryStream} object
     */
    @Override
    public DirectoryStream&lt;Path&gt; newDirectoryStream(Path dir, DirectoryStream.Filter&lt;? super Path&gt; filter) throws IOException {
        try {
<span class="nc" id="L224">            return this.newDirectoryStream(null, dir, filter);</span>
<span class="nc" id="L225">        } catch (ExecutionException e) {</span>
<span class="nc" id="L226">            throw new IOException(e);</span>
<span class="nc" id="L227">        } catch (InterruptedException e) {</span>
<span class="nc" id="L228">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L229">            throw new RuntimeException(e);</span>
        }
    }

    /**
     * Get a new directory stream that will use the specified client. A composable and testable version of the public
     * version of {@code newDirectoryStream}
     */
    protected DirectoryStream&lt;Path&gt; newDirectoryStream(S3AsyncClient s3Client, Path dir, DirectoryStream.Filter&lt;? super Path&gt; filter) throws ExecutionException, InterruptedException {
<span class="fc" id="L238">        S3Path s3Path = (S3Path) dir;</span>

<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (s3Client == null) {</span>
<span class="nc" id="L241">            s3Client = S3ClientStore.getInstance().getAsyncClientForBucketName(s3Path.bucketName());</span>
        }

<span class="fc" id="L244">        String pathString = s3Path.toRealPath(NOFOLLOW_LINKS).toString();</span>
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">        if (!pathString.endsWith(S3Path.PATH_SEPARATOR) &amp;&amp; !pathString.isEmpty()) {</span>
<span class="fc" id="L246">            pathString = pathString + S3Path.PATH_SEPARATOR;</span>
        }

<span class="fc" id="L249">        final String bucketName = s3Path.bucketName();</span>
<span class="fc" id="L250">        final S3FileSystem fs = new S3FileSystem(bucketName);</span>
<span class="fc" id="L251">        final String prefix = pathString;</span>

<span class="fc" id="L253">        long timeOut = TIMEOUT_TIME_LENGTH_1;</span>
<span class="fc" id="L254">        final TimeUnit unit = MINUTES;</span>
        try {
<span class="pc" id="L256">            final Iterator&lt;S3Path&gt; filteredDirectoryContents = s3Client.listObjectsV2(req -&gt; req</span>
<span class="nc" id="L257">                            .bucket(bucketName)</span>
<span class="nc" id="L258">                            .prefix(prefix))</span>
<span class="fc" id="L259">                    .get(timeOut, unit)</span>
<span class="fc" id="L260">                    .contents()</span>
<span class="fc" id="L261">                    .stream()</span>
<span class="fc" id="L262">                    .map(s3Object -&gt; truncateByPrefix(fs, prefix, s3Object))</span>
<span class="fc" id="L263">                    .filter(path -&gt; {</span>
                        try {
<span class="fc" id="L265">                            return filter.accept(path);</span>
<span class="nc" id="L266">                        } catch (IOException e) {</span>
<span class="nc" id="L267">                            e.printStackTrace();</span>
<span class="nc" id="L268">                            return false;</span>
                        }})
<span class="fc" id="L270">                    .iterator();</span>

<span class="fc" id="L272">            return new DirectoryStream&lt;Path&gt;() {</span>
<span class="fc" id="L273">                final Iterator&lt;? extends Path&gt; iterator = filteredDirectoryContents;</span>

                @Override
                @SuppressWarnings(&quot;unchecked&quot;)
                public Iterator&lt;Path&gt; iterator() {
<span class="fc" id="L278">                    return (Iterator&lt;Path&gt;) iterator;</span>
                }

                @Override
                public void close() {
                    // nothing to close
<span class="nc" id="L284">                }</span>
            };
<span class="nc" id="L286">        } catch (TimeoutException e) {</span>
<span class="nc" id="L287">            throw logAndGenerateExceptionOnTimeOut(logger, &quot;newDirectoryStream&quot;, timeOut, unit);</span>
        }
    }

    /**
     * truncate objects whose key after the prefix contains a &quot;/&quot; to the first &quot;/&quot; after the prefix
     */
    private S3Path truncateByPrefix(final S3FileSystem fs, final String prefix, final S3Object object){
<span class="pc bpc" id="L295" title="3 of 4 branches missed.">        if(object.key().indexOf(prefix) != 0 || object.key().equals(prefix)) {</span>
<span class="fc" id="L296">            return S3Path.getPath(fs, object);</span>
        }

<span class="nc" id="L299">        int indexOfNextSeparator = object.key().indexOf(S3Path.PATH_SEPARATOR, prefix.length());</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        String truncated = indexOfNextSeparator == -1 ? object.key() : object.key().substring(0, indexOfNextSeparator);</span>
<span class="nc" id="L301">        return fs.getPath(truncated);</span>
    }

    /**
     * Creates a new directory. This method works in exactly the manner
     * specified by the {@link Files#createDirectory} method.
     *
     * @param dir   the directory to create
     * @param attrs an optional list of file attributes to set atomically when
     *              creating the directory
     */
    @Override
    public void createDirectory(Path dir, FileAttribute&lt;?&gt;... attrs) {
<span class="fc" id="L314">        throw new UnsupportedOperationException(&quot;write operations are not currently supported, please file a feature request with your use case&quot;);</span>
    }

    /**
     * Deletes a file. This method works in exactly the  manner specified by the
     * {@link Files#delete} method.
     *
     * @param path the path to the file to delete
     */
    @Override
    public void delete(Path path) {
<span class="fc" id="L325">        throw new UnsupportedOperationException(&quot;write operations are not currently supported, please file a feature request with your use case&quot;);</span>
    }

    /**
     * Copy a file to a target file. This method works in exactly the manner
     * specified by the {@link Files#copy(Path, Path, CopyOption[])} method
     * except that both the source and target paths must be associated with
     * this provider.
     *
     * @param source  the path to the file to copy
     * @param target  the path to the target file
     * @param options options specifying how the copy should be done
     */
    @Override
    public void copy(Path source, Path target, CopyOption... options) {
<span class="fc" id="L340">        throw new UnsupportedOperationException(&quot;currently only read operations are supported, please file a feature request with your use case&quot;);</span>

        //for large files we will need to use MultiPartCopy and a thread pool, so it doesn't take forever
    }

    /**
     * Move or rename a file to a target file. This method works in exactly the
     * manner specified by the {@link Files#move} method except that both the
     * source and target paths must be associated with this provider.
     *
     * @param source  the path to the file to move
     * @param target  the path to the target file
     * @param options options specifying how the move should be done
     */
    @Override
    public void move(Path source, Path target, CopyOption... options) {
<span class="fc" id="L356">        throw new UnsupportedOperationException(&quot;currently only read operations are supported, please file a feature request with your use case&quot;);</span>

    }

    /**
     * Tests if two paths locate the same file. This method works in exactly the
     * manner specified by the {@link Files#isSameFile} method.
     *
     * @param path  one path to the file
     * @param path2 the other path
     * @return {@code true} if, and only if, the two paths locate the same file
     * @throws IOException       if an I/O error occurs
     * @throws SecurityException In the case of the default provider, and a security manager is
     *                           installed, the {@link SecurityManager#checkRead(String) checkRead}
     *                           method is invoked to check read access to both files.
     */
    @Override
    public boolean isSameFile(Path path, Path path2) throws IOException {
<span class="fc" id="L374">        return path.toRealPath(NOFOLLOW_LINKS).equals(path2.toRealPath(NOFOLLOW_LINKS));</span>
    }

    /**
     * There are no hidden files in S3
     *
     * @param path the path to the file to test
     * @return {@code false} always
     */
    @Override
    public boolean isHidden(Path path) {
<span class="fc" id="L385">        return false;</span>
    }

    /**
     * S3 buckets don't have partitions or volumes so there are no file stores
     *
     * @param path the path to the file
     * @return {@code null} always
     */
    @Override
    public FileStore getFileStore(Path path) {
<span class="fc" id="L396">        return null;</span>
    }

    /**
     * Checks the existence, and optionally the accessibility, of a file.
     *
     * &lt;p&gt; This method may be used by the {@link Files#isReadable isReadable},
     * {@link Files#isWritable isWritable} and {@link Files#isExecutable
     * isExecutable} methods to check the accessibility of a file.
     *
     * &lt;p&gt; This method checks the existence of a file and that this Java virtual
     * machine has appropriate privileges that would allow it to access the file
     * according to all the access modes specified in the {@code modes} parameter
     * as follows:
     *
     * &lt;table class=&quot;striped&quot;&gt;
     * &lt;caption style=&quot;display:none&quot;&gt;Access Modes&lt;/caption&gt;
     * &lt;thead&gt;
     * &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;Value&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt; &lt;/tr&gt;
     * &lt;/thead&gt;
     * &lt;tbody&gt;
     * &lt;tr&gt;
     *   &lt;th scope=&quot;row&quot;&gt; {@link AccessMode#READ READ} &lt;/th&gt;
     *   &lt;td&gt; Checks that the file exists and that the Java virtual machine has
     *     permission to read the file. &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *   &lt;th scope=&quot;row&quot;&gt; {@link AccessMode#WRITE WRITE} &lt;/th&gt;
     *   &lt;td&gt; Checks that the file exists and that the Java virtual machine has
     *     permission to write to the file, &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     *   &lt;th scope=&quot;row&quot;&gt; {@link AccessMode#EXECUTE EXECUTE} &lt;/th&gt;
     *   &lt;td&gt; Checks that the file exists and that the Java virtual machine has
     *     permission to {@link Runtime#exec execute} the file. The semantics
     *     may differ when checking access to a directory. For example, on UNIX
     *     systems, checking for {@code EXECUTE} access checks that the Java
     *     virtual machine has permission to search the directory in order to
     *     access file or subdirectories. &lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/tbody&gt;
     * &lt;/table&gt;
     *
     * &lt;p&gt; If the {@code modes} parameter is of length zero, then the existence
     * of the file is checked.
     *
     * &lt;p&gt; This method follows symbolic links if the file referenced by this
     * object is a symbolic link. Depending on the implementation, this method
     * may require reading file permissions, access control lists, or other
     * file attributes in order to check the effective access to the file. To
     * determine the effective access to a file may require access to several
     * attributes and so in some implementations this method may not be atomic
     * with respect to other file system operations.
     *
     * @param path  the path to the file to check
     * @param modes The access modes to check; may have zero elements
     * @throws UnsupportedOperationException an implementation is required to support checking for
     *                                       {@code READ}, {@code WRITE}, and {@code EXECUTE} access. This
     *                                       exception is specified to allow for the {@code Access} enum to
     *                                       be extended in future releases.
     * @throws NoSuchFileException           if a file does not exist &lt;i&gt;(optional specific exception)&lt;/i&gt;
     * @throws AccessDeniedException         the requested access would be denied or the access cannot be
     *                                       determined because the Java virtual machine has insufficient
     *                                       privileges or other reasons. &lt;i&gt;(optional specific exception)&lt;/i&gt;
     * @throws IOException                   if an I/O error occurs
     * @throws SecurityException             In the case of the default provider, and a security manager is
     *                                       installed, the {@link SecurityManager#checkRead(String) checkRead}
     *                                       is invoked when checking read access to the file or only the
     *                                       existence of the file, the {@link SecurityManager#checkWrite(String)
     *                                       checkWrite} is invoked when checking write access to the file,
     *                                       and {@link SecurityManager#checkExec(String) checkExec} is invoked
     *                                       when checking execute access.
     */
    @Override
    public void checkAccess(Path path, AccessMode... modes) throws IOException {
        try {
<span class="nc" id="L472">            this.checkAccess(null, path, modes);</span>
<span class="nc" id="L473">        } catch (ExecutionException e) {</span>
<span class="nc" id="L474">            throw new IOException(e);</span>
<span class="nc" id="L475">        } catch (InterruptedException e) {</span>
<span class="nc" id="L476">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L477">            throw new RuntimeException(e);</span>
<span class="nc" id="L478">        }</span>
<span class="nc" id="L479">    }</span>

    /**
     * Composable and testable version of {@code checkAccess} that uses the provided client to check access
     */
    protected void checkAccess(S3AsyncClient s3Client, Path path, AccessMode... modes) throws IOException, ExecutionException, InterruptedException {
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (Arrays.asList(modes).contains(AccessMode.WRITE)){</span>
<span class="fc" id="L486">            throw new UnsupportedOperationException(&quot;WRITE is not currently supported. Please raise a feature request if you want this.&quot;);</span>
        }

<span class="pc bpc" id="L489" title="2 of 4 branches missed.">        assert path instanceof S3Path;</span>
<span class="fc" id="L490">        S3Path s3Path = (S3Path) path.toRealPath(NOFOLLOW_LINKS);</span>
<span class="fc" id="L491">        final String bucketName = s3Path.getFileSystem().bucketName();</span>

<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        if(s3Client == null){</span>
<span class="nc" id="L494">            s3Client = S3ClientStore.getInstance().getAsyncClientForBucketName(bucketName);</span>
        }

        final CompletableFuture&lt;? extends S3Response&gt; response;
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if(s3Path.equals(s3Path.getRoot())){</span>
<span class="nc" id="L499">            response = s3Client.headBucket(request -&gt; request.bucket(bucketName));</span>
        } else {
<span class="pc" id="L501">            response = s3Client.headObject(req -&gt; req.bucket(bucketName).key(s3Path.getKey()));</span>
        }

<span class="fc" id="L504">        long timeOut = TimeOutUtils.TIMEOUT_TIME_LENGTH_1;</span>
<span class="fc" id="L505">        TimeUnit unit = MINUTES;</span>

        try {
<span class="fc" id="L508">            SdkHttpResponse httpResponse = response.get(timeOut, unit).sdkHttpResponse();</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (httpResponse.isSuccessful()) return;</span>

<span class="fc bfc" id="L511" title="All 2 branches covered.">            if (httpResponse.statusCode() == FORBIDDEN)</span>
<span class="fc" id="L512">                throw new AccessDeniedException(s3Path.toString());</span>

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">            if (httpResponse.statusCode() == NOT_FOUND)</span>
<span class="fc" id="L515">                throw new NoSuchFileException(s3Path.toString());</span>

<span class="nc" id="L517">            throw new IOException(String.format(&quot;exception occurred while checking access, response code was '%d'&quot;,</span>
<span class="nc" id="L518">                    httpResponse.statusCode()));</span>

<span class="nc" id="L520">        } catch (TimeoutException e){</span>
<span class="nc" id="L521">            throw logAndGenerateExceptionOnTimeOut(logger, &quot;checkAccess&quot;, timeOut, unit);</span>
        }
    }

    /**
     * Returns a file attribute view of a given type. This method works in
     * exactly the manner specified by the {@link Files#getFileAttributeView}
     * method.
     *
     * @param path    the path to the file
     * @param type    the {@code Class} object corresponding to the file attribute view.
     *                Must be {@code BasicFileAttributeView.class} or {@code S3FileAttributeView.class}
     * @param options ignored as there are no links in S3
     * @return a file attribute view of the specified type, or {@code null} if
     * the attribute view type is not available
     */
    @Override
    public &lt;V extends FileAttributeView&gt; V getFileAttributeView(Path path, Class&lt;V&gt; type, LinkOption... options) {
<span class="fc" id="L539">        Objects.requireNonNull(path, &quot;cannot obtain attributes for a null path&quot;);</span>
<span class="fc" id="L540">        Objects.requireNonNull(type, &quot;the type of attribute view required cannot be null&quot;);</span>

<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if(!(path instanceof S3Path)) throw new IllegalArgumentException(&quot;path must be an S3 Path&quot;);</span>
<span class="fc" id="L543">        S3Path s3Path = (S3Path) path;</span>

<span class="fc bfc" id="L545" title="All 4 branches covered.">        if(type.equals(BasicFileAttributeView.class) || type.equals(S3FileAttributeView.class)){</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L547">            final V v = (V) new S3FileAttributeView(s3Path);</span>
<span class="fc" id="L548">            return v;</span>
        } else {
<span class="fc" id="L550">            throw new IllegalArgumentException(&quot;type must be BasicFileAttributeView.class or S3FileAttributeView.class&quot;);</span>
        }
    }

    /**
     * Reads a file's attributes as a bulk operation. This method works in
     * exactly the manner specified by the {@link
     * Files#readAttributes(Path, Class, LinkOption[])} method.
     *
     * @param path    the path to the file
     * @param type    the {@code Class} of the file attributes required
     *                to read. Supported types are {@code BasicFileAttributes} and {@code S3FileAttributes}
     * @param options options indicating how symbolic links are handled
     * @return the file attributes or {@code null} if {@code path} is inferred to be a directory.
     */
    @Override
    public &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path, Class&lt;A&gt; type, LinkOption... options) {
<span class="nc" id="L567">       return this.readAttributes(null, path, type, options);</span>
    }

    protected &lt;A extends BasicFileAttributes&gt; A readAttributes(S3AsyncClient s3AsyncClient, Path path, Class&lt;A&gt; type, LinkOption... options) {
<span class="fc" id="L571">        Objects.requireNonNull(path);</span>
<span class="fc" id="L572">        Objects.requireNonNull(type);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">        if(!(path instanceof S3Path)) throw new IllegalArgumentException(&quot;path must be an S3Path instance&quot;);</span>
<span class="fc" id="L574">        S3Path s3Path = (S3Path) path;</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        if(s3Path.isDirectory()) return null;</span>

<span class="pc bpc" id="L577" title="1 of 4 branches missed.">        if(type.equals(BasicFileAttributes.class) || type.equals(S3BasicFileAttributes.class)){</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            if(s3AsyncClient == null){</span>
<span class="nc" id="L579">                s3AsyncClient = S3ClientStore.getInstance().getAsyncClientForBucketName(s3Path.bucketName());</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L582">            A a = (A) new S3BasicFileAttributes(s3Path, s3AsyncClient);</span>
<span class="fc" id="L583">            return a;</span>
        } else {
<span class="nc" id="L585">            throw new UnsupportedOperationException(&quot;cannot read attributes of type: &quot;+type);</span>
        }
    }

    /**
     * Reads a set of file attributes as a bulk operation. Largely equivalent to {@code readAttributes(Path path, Class&lt;A&gt; type, LinkOption... options)}
     * where the returned object is a map of method names (attributes) to values, filtered on the comma separated {@code attributes}.
     *
     * @param path       the path to the file
     * @param attributes the comma separated attributes to read. May be prefixed with &quot;s3:&quot;
     * @param options    ignored, S3 has no links
     * @return a map of the attributes returned; may be empty. The map's keys
     * are the attribute names, its values are the attribute values. Returns an empty map if {@code attributes} is empty,
     * or if {@code path} is inferred to be a directory.
     * @throws UnsupportedOperationException if the attribute view is not available
     * @throws IllegalArgumentException      if no attributes are specified or an unrecognized attributes is
     *                                       specified
     * @throws SecurityException             In the case of the default provider, and a security manager is
     *                                       installed, its {@link SecurityManager#checkRead(String) checkRead}
     *                                       method denies read access to the file. If this method is invoked
     *                                       to read security sensitive attributes then the security manager
     *                                       may be invoked to check for additional permissions.
     */
    @Override
    public Map&lt;String, Object&gt; readAttributes(Path path, String attributes, LinkOption... options) {
<span class="nc" id="L610">        return this.readAttributes(null, path, attributes, options);</span>
    }

    protected Map&lt;String, Object&gt; readAttributes(S3AsyncClient client, Path path, String attributes, LinkOption... options) {
<span class="fc" id="L614">        Objects.requireNonNull(path);</span>
<span class="fc" id="L615">        Objects.requireNonNull(attributes);</span>
<span class="fc" id="L616">        S3Path s3Path = (S3Path) path;</span>

<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if (client == null) {</span>
<span class="nc" id="L619">            client = S3ClientStore.getInstance().getAsyncClientForBucketName(s3Path.bucketName());</span>
        }

<span class="pc bpc" id="L622" title="1 of 4 branches missed.">        if(s3Path.isDirectory() || attributes.trim().isEmpty()) return Collections.emptyMap();</span>

<span class="pc bpc" id="L624" title="1 of 4 branches missed.">        if(attributes.equals(&quot;*&quot;) || attributes.equals(&quot;s3&quot;)) return new S3BasicFileAttributes(s3Path, client).asMap();</span>

<span class="fc" id="L626">        final Set&lt;String&gt; attrSet = Arrays.stream(attributes.split(&quot;,&quot;))</span>
<span class="fc" id="L627">                .map(attr -&gt; attr.replaceAll(&quot;^s3:&quot;, &quot;&quot;))</span>
<span class="fc" id="L628">                .collect(Collectors.toSet());</span>
<span class="fc" id="L629">        return readAttributes(client, path, S3BasicFileAttributes.class, options)</span>
<span class="fc" id="L630">                .asMap(attrSet::contains);</span>
    }

    /**
     * File attributes of S3 objects cannot be set other than by creating a new object
     * @throws UnsupportedOperationException always
     */
    @Override
    public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws UnsupportedOperationException {
<span class="fc" id="L639">        throw new UnsupportedOperationException(&quot;s3 file attributes cannot be modified by this class&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>