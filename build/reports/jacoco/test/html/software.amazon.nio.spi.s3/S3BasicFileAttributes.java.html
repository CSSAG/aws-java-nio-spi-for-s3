<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>S3BasicFileAttributes.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s3fs-spi</a> &gt; <a href="index.source.html" class="el_package">software.amazon.nio.spi.s3</a> &gt; <span class="el_source">S3BasicFileAttributes.java</span></div><h1>S3BasicFileAttributes.java</h1><pre class="source lang-java linenums">/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package software.amazon.nio.spi.s3;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import software.amazon.nio.spi.s3.util.TimeOutUtils;
import software.amazon.awssdk.services.s3.S3AsyncClient;

import java.lang.reflect.InvocationTargetException;
import java.nio.file.Files;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.lang.String.format;
import static java.util.concurrent.TimeUnit.MINUTES;

public class S3BasicFileAttributes implements BasicFileAttributes {

    private final S3Path path;
    private final S3AsyncClient client;
    private final String bucketName;

<span class="fc" id="L37">    private final Set&lt;String&gt; methodNamesToFilterOut =</span>
<span class="fc" id="L38">            Stream.of(&quot;wait&quot;,&quot;toString&quot;,&quot;hashCode&quot;,&quot;getClass&quot;,&quot;notify&quot;,&quot;notifyAll&quot;).collect(Collectors.toSet());</span>

<span class="fc" id="L40">    private final Logger logger = LoggerFactory.getLogger(this.getClass().getName());</span>

    protected S3BasicFileAttributes(S3Path path){
<span class="nc" id="L43">        this(path, S3ClientStore.getInstance().getAsyncClientForBucketName(path.bucketName()));</span>
<span class="nc" id="L44">    }</span>

<span class="fc" id="L46">    protected S3BasicFileAttributes(S3Path path, S3AsyncClient client){</span>
<span class="fc" id="L47">        this.path = path;</span>
<span class="fc" id="L48">        this.client = client;</span>
<span class="fc" id="L49">        bucketName = path.bucketName();</span>
<span class="fc" id="L50">    }</span>

    /**
     * Returns the time of last modification.
     *
     * &lt;p&gt; S3 &quot;directories&quot; do not support a time stamp
     * to indicate the time of last modification therefore this method returns a default value
     * representing the epoch (1970-01-01T00:00:00Z) as a proxy
     *
     * @return a {@code FileTime} representing the time the file was last
     * modified.
     * @throws RuntimeException if the S3Clients {@code RetryConditions} configuration was not able to handle the exception.
     */
    @Override
    public FileTime lastModifiedTime() {
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if(path.isDirectory()){</span>
<span class="nc" id="L66">            return FileTime.from(Instant.EPOCH);</span>
        }

        final Instant lastModified;
        try {
<span class="pc" id="L71">            lastModified = client.headObject(req -&gt; req</span>
<span class="nc" id="L72">                    .bucket(bucketName)</span>
<span class="nc" id="L73">                    .key(path.getKey())</span>
<span class="fc" id="L74">            ).get(TimeOutUtils.TIMEOUT_TIME_LENGTH_1, MINUTES).lastModified();</span>
<span class="nc" id="L75">        } catch (ExecutionException e) {</span>
<span class="nc" id="L76">            String errMsg = format(&quot;an '%s' error occurred while obtaining the last modified time of '%s' that was not handled successfully by the S3Client's configured RetryConditions&quot;, e.getCause().toString(), path.toUri());</span>
<span class="nc" id="L77">            logger.error(errMsg);</span>
<span class="nc" id="L78">            throw new RuntimeException(errMsg, e);</span>
<span class="nc" id="L79">        } catch (InterruptedException e) {</span>
<span class="nc" id="L80">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L81">            throw new RuntimeException(e);</span>
<span class="nc" id="L82">        } catch (TimeoutException e) {</span>
<span class="nc" id="L83">            throw TimeOutUtils.logAndGenerateExceptionOnTimeOut(logger, &quot;lastModifiedTime()&quot;, TimeOutUtils.TIMEOUT_TIME_LENGTH_1, MINUTES);</span>
<span class="fc" id="L84">        }</span>
<span class="fc" id="L85">        return FileTime.from(lastModified);</span>
    }

    /**
     * Returns the time of last access.
     * &lt;p&gt;Without enabling S3 server access logging, CloudTrail or similar it is not possible to obtain the access time
     * of an object, therefore the current implementation will return the @{code lastModifiedTime}&lt;/p&gt;
     *
     * @return a {@code FileTime} representing the time of last access
     */
    @Override
    public FileTime lastAccessTime() {
<span class="fc" id="L97">        return lastModifiedTime();</span>
    }

    /**
     * Returns the creation time. The creation time is the time that the file
     * was created.
     *
     * &lt;p&gt; Any modification of an S3 object results in a new Object so this time will be the same as
     * {@code lastModifiedTime}. A future implementation could consider times for versioned objects.
     *
     * @return a {@code FileTime} representing the time the file was created
     */
    @Override
    public FileTime creationTime() {
<span class="fc" id="L111">        return lastModifiedTime();</span>
    }

    /**
     * Tells whether the file is a regular file with opaque content.
     *
     * @return {@code true} if the file is a regular file with opaque content
     */
    @Override
    public boolean isRegularFile() {
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        return !path.isDirectory();</span>
    }

    /**
     * Tells whether the file is a directory.
     *
     * @return {@code true} if the file is a directory
     */
    @Override
    public boolean isDirectory() {
<span class="fc" id="L131">        return path.isDirectory();</span>
    }

    /**
     * Tells whether the file is a symbolic link.
     *
     * @return {@code false} always as S3 has no links
     */
    @Override
    public boolean isSymbolicLink() {
<span class="fc" id="L141">        return false;</span>
    }

    /**
     * Tells whether the file is something other than a regular file, directory,
     * or symbolic link. There are only objects in S3 and inferred directories
     *
     * @return {@code false} always
     */
    @Override
    public boolean isOther() {
<span class="fc" id="L152">        return false;</span>
    }

    /**
     * Returns the size of the file (in bytes). The size may differ from the
     * actual size on the file system due to compression, support for sparse
     * files, or other reasons. The size of files that are not {@link
     * #isRegularFile regular} files is implementation specific and
     * therefore unspecified.
     *
     * @return the file size, in bytes
     * @throws RuntimeException if the S3Clients {@code RetryConditions} configuration was not able to handle the exception.
     */
    @Override
    public long size() throws RuntimeException{
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if(isDirectory()) return 0;</span>

        try {
<span class="pc" id="L170">            return client.headObject(req -&gt; req</span>
<span class="nc" id="L171">                    .bucket(bucketName)</span>
<span class="nc" id="L172">                    .key(path.getKey())</span>
<span class="fc" id="L173">            ).get(TimeOutUtils.TIMEOUT_TIME_LENGTH_1, MINUTES).contentLength();</span>
<span class="nc" id="L174">        } catch (ExecutionException e) {</span>
<span class="nc" id="L175">            String errMsg = format(&quot;an '%s' error occurred while obtaining the size of '%s' that was not handled successfully by the S3Client's configured RetryConditions&quot;, e.getCause().toString(), path.toUri());</span>
<span class="nc" id="L176">            logger.error(errMsg);</span>
<span class="nc" id="L177">            throw new RuntimeException(errMsg, e);</span>
<span class="nc" id="L178">        } catch (InterruptedException e) {</span>
<span class="nc" id="L179">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L180">            throw new RuntimeException(e);</span>
<span class="nc" id="L181">        } catch (TimeoutException e){</span>
<span class="nc" id="L182">            throw TimeOutUtils.logAndGenerateExceptionOnTimeOut(logger, &quot;size()&quot;, TimeOutUtils.TIMEOUT_TIME_LENGTH_1, MINUTES);</span>
        }
    }

    /**
     * Returns the S3 etag for the object
     *
     * @return the etag for an object, or {@code null} for a &quot;directory&quot;
     * @see Files#walkFileTree
     * @throws RuntimeException if the S3Clients {@code RetryConditions} configuration was not able to handle the exception.
     */
    @Override
    public Object fileKey() {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (path.isDirectory()) return null;</span>

        try {
<span class="pc" id="L198">            return client.headObject(req -&gt; req</span>
<span class="nc" id="L199">                    .bucket(bucketName)</span>
<span class="nc" id="L200">                    .key(path.toString())</span>
<span class="fc" id="L201">            ).get(TimeOutUtils.TIMEOUT_TIME_LENGTH_1, MINUTES).eTag();</span>
<span class="nc" id="L202">        } catch (ExecutionException e) {</span>
<span class="nc" id="L203">            String errMsg = format(&quot;an '%s' error occurred while obtaining the file key of '%s' that was not handled successfully by the S3Client's configured RetryConditions&quot;, e.getCause().toString(), path.toUri());</span>
<span class="nc" id="L204">            logger.error(errMsg);</span>
<span class="nc" id="L205">            throw new RuntimeException(errMsg, e);</span>
<span class="nc" id="L206">        } catch (InterruptedException e) {</span>
<span class="nc" id="L207">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L208">            throw new RuntimeException(e);</span>
<span class="nc" id="L209">        } catch (TimeoutException e){</span>
<span class="nc" id="L210">            throw TimeOutUtils.logAndGenerateExceptionOnTimeOut(logger, &quot;size()&quot;, TimeOutUtils.TIMEOUT_TIME_LENGTH_1, MINUTES);</span>
        }
    }

    protected Map&lt;String, Object&gt; asMap(){
<span class="fc" id="L215">        return asMap(x -&gt; true);</span>
    }

    protected Map&lt;String, Object&gt; asMap(Predicate&lt;String&gt; attributeFilter){
<span class="fc" id="L219">        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L220">        Arrays.stream(this.getClass().getMethods())</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                .filter(method -&gt; method.getParameterCount() == 0)</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">                .filter(method -&gt; !methodNamesToFilterOut.contains(method.getName()))</span>
<span class="fc" id="L223">                .filter(method -&gt; attributeFilter.test(method.getName()))</span>
<span class="fc" id="L224">                .forEach(method -&gt; {</span>
<span class="fc" id="L225">                    logger.debug(&quot;method name: '{}'&quot;, method.getName());</span>
                    try {
<span class="fc" id="L227">                        map.put(method.getName(), method.invoke(this));</span>
<span class="nc" id="L228">                    } catch (IllegalAccessException | InvocationTargetException e) {</span>
                        // should not ever happen as these are all public no arg methods
<span class="nc" id="L230">                        String errorMsg = format(</span>
<span class="nc" id="L231">                                &quot;an exception has occurred during a reflection operation on the methods of the file attributes of '%s', check if your Java SecurityManager is configured to allow reflection.&quot;, path.toUri());</span>
<span class="nc" id="L232">                        logger.error(&quot;{}, caused by {}&quot;, errorMsg, e.getCause().getMessage());</span>
<span class="nc" id="L233">                        throw new RuntimeException(errorMsg, e);</span>
<span class="fc" id="L234">                    }</span>
<span class="fc" id="L235">                });</span>

<span class="fc" id="L237">        return map;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>