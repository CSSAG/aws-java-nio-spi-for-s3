<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>S3ReadAheadByteChannel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s3fs-spi</a> &gt; <a href="index.source.html" class="el_package">software.amazon.nio.spi.s3</a> &gt; <span class="el_source">S3ReadAheadByteChannel.java</span></div><h1>S3ReadAheadByteChannel.java</h1><pre class="source lang-java linenums">/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

package software.amazon.nio.spi.s3;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.stats.CacheStats;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import software.amazon.awssdk.core.BytesWrapper;
import software.amazon.awssdk.core.async.AsyncResponseTransformer;
import software.amazon.awssdk.services.s3.S3AsyncClient;
import software.amazon.nio.spi.s3.util.TimeOutUtils;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;

/**
 * A {@code ReadableByteChannel} delegate for an {@code S3SeekableByteChannel} that maintains internal read ahead
 * buffers to reduce the amount of high latency
 * requests to S3. If the bytes required by a read are already in the buffer, they will be fulfilled from the buffer
 * rather than making another S3 request.
 * &lt;p&gt;As reads are made this object will update the current read position of the delegating {@code S3SeekableByteChannel}&lt;/p&gt;
 */
public class S3ReadAheadByteChannel implements ReadableByteChannel {

    private final S3AsyncClient client;
    private final S3Path path;
    private final S3SeekableByteChannel delegator;
    private final int maxFragmentSize;
    private final int maxNumberFragments;
    private final int numFragmentsInObject;
    private final long size;
    private boolean open;
    private final Cache&lt;Integer, CompletableFuture&lt;ByteBuffer&gt;&gt; readAheadBuffersCache;

<span class="fc" id="L49">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span>


    /**
     * Construct a new {@code S3ReadAheadByteChannel} which is used by its parent delegator to perform read operations.
     * The channel is backed by a cache that holds the buffered fragments of the object identified
     * by the {@code path}.
     * @param path the path to the S3 object being read
     * @param maxFragmentSize the maximum amount of bytes in a read ahead fragment. Must be &gt;= 1.
     * @param maxNumberFragments the maximum number of read ahead fragments to hold. Must be &gt;= 2.
     * @param client the client used to read from the {@code path}
     * @param delegator the {@code S3SeekableByteChannel} that delegates reading to this object.
     * @throws IOException if a problem occurs initializing the cached fragments
     */
<span class="fc" id="L63">    public S3ReadAheadByteChannel(S3Path path, int maxFragmentSize, int maxNumberFragments, S3AsyncClient client, S3SeekableByteChannel delegator) throws IOException {</span>
<span class="fc" id="L64">        Objects.requireNonNull(path);</span>
<span class="fc" id="L65">        Objects.requireNonNull(client);</span>
<span class="fc" id="L66">        Objects.requireNonNull(delegator);</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if(maxFragmentSize &lt; 1) throw new IllegalArgumentException(&quot;maxFragmentSize must be &gt;= 1&quot;);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        if(maxNumberFragments &lt; 2) throw new IllegalArgumentException(&quot;maxNumberFragments must be &gt;= 2&quot;);</span>

<span class="fc" id="L70">        logger.info(&quot;max read ahead fragments '{}' with size '{}' bytes&quot;, maxNumberFragments, maxFragmentSize);</span>
<span class="fc" id="L71">        this.client = client;</span>
<span class="fc" id="L72">        this.path = path;</span>
<span class="fc" id="L73">        this.delegator = delegator;</span>
<span class="fc" id="L74">        this.size = delegator.size();</span>
<span class="fc" id="L75">        this.maxFragmentSize = maxFragmentSize;</span>
<span class="fc" id="L76">        this.numFragmentsInObject = (int) Math.ceil((float) size / (float)maxFragmentSize);</span>
<span class="fc" id="L77">        this.readAheadBuffersCache = Caffeine.newBuilder().maximumSize(maxNumberFragments).recordStats().build();</span>
<span class="fc" id="L78">        this.maxNumberFragments = maxNumberFragments;</span>
<span class="fc" id="L79">        this.open = true;</span>
<span class="fc" id="L80">    }</span>

    @Override
    public int read(ByteBuffer dst) throws IOException {
<span class="nc" id="L84">        Objects.requireNonNull(dst);</span>

<span class="nc" id="L86">        long channelPosition = delegator.position();</span>
<span class="nc" id="L87">        logger.debug(&quot;delegator position: {}&quot;, channelPosition);</span>

        // if the position of the delegator is at the end (&gt;= size) return -1. we're finished reading.
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (channelPosition &gt;= size) return -1;</span>

        //figure out the index of the fragment the bytes would start in
<span class="nc" id="L93">        Integer fragmentIndex = fragmentIndexForByteNumber(channelPosition);</span>
<span class="nc" id="L94">        logger.debug(&quot;fragment index: {}&quot;, fragmentIndex);</span>

<span class="nc" id="L96">        int fragmentOffset = (int) (channelPosition - (fragmentIndex.longValue() * maxFragmentSize));</span>
<span class="nc" id="L97">        logger.debug(&quot;fragment {} offset: {}&quot;, fragmentIndex, fragmentOffset);</span>

        try {
<span class="nc" id="L100">            final ByteBuffer fragment = Objects.requireNonNull(readAheadBuffersCache.get(fragmentIndex, this::computeFragmentFuture))</span>
<span class="nc" id="L101">                    .get(TimeOutUtils.TIMEOUT_TIME_LENGTH_5, TimeUnit.MINUTES)</span>
<span class="nc" id="L102">                    .asReadOnlyBuffer();</span>

<span class="nc" id="L104">            fragment.position(fragmentOffset);</span>
<span class="nc" id="L105">            logger.debug(&quot;fragment remaining: {}&quot;, fragment.remaining());</span>
<span class="nc" id="L106">            logger.debug(&quot;dst remaining: {}&quot;, dst.remaining());</span>

            //put the bytes from fragment from the offset upto the min of fragment remaining or dst remaining
<span class="nc" id="L109">            int limit = Math.min(fragment.remaining(), dst.remaining());</span>
<span class="nc" id="L110">            logger.debug(&quot;byte limit: {}&quot;, limit);</span>

<span class="nc" id="L112">            byte[] copiedBytes = new byte[limit];</span>
<span class="nc" id="L113">            fragment.get(copiedBytes, 0, limit);</span>
<span class="nc" id="L114">            dst.put(copiedBytes);</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">            if(fragment.position() &gt;= fragment.limit() / 2){</span>

                // clear any fragments in cache that are lower index than this one
<span class="nc" id="L119">                clearPriorFragments(fragmentIndex);</span>

                // until available cache slots are filled or number of fragments in file
<span class="nc" id="L122">                int maxFragmentsToLoad = Math.min(maxNumberFragments -1, numFragmentsInObject - fragmentIndex -1);</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">                for (int i = 0; i &lt; maxFragmentsToLoad; i++) {</span>
<span class="nc" id="L125">                    final int idxToLoad = i + fragmentIndex + 1;</span>

                    //  add the index if it's not already there
<span class="nc bnc" id="L128" title="All 2 branches missed.">                    if(readAheadBuffersCache.asMap().containsKey(idxToLoad)) continue;</span>

<span class="nc" id="L130">                    logger.debug(&quot;initiate pre-loading fragment with index '{}' from '{}'&quot;, idxToLoad, path.toUri());</span>
<span class="nc" id="L131">                    readAheadBuffersCache.put(idxToLoad, computeFragmentFuture(idxToLoad));</span>
                }
            }

<span class="nc" id="L135">            delegator.position(channelPosition + copiedBytes.length);</span>
<span class="nc" id="L136">            return copiedBytes.length;</span>

<span class="nc" id="L138">        } catch (InterruptedException e){</span>
<span class="nc" id="L139">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L140">            throw new RuntimeException(e);</span>
<span class="nc" id="L141">        } catch (ExecutionException e) {</span>
            // the async execution completed exceptionally.
            // not currently obvious when this will happen or if we can recover
<span class="nc" id="L144">            logger.error(&quot;an exception occurred while reading bytes from {} that was not recovered by the S3 Client RetryCondition(s)&quot;, path.toUri());</span>
<span class="nc" id="L145">            throw new IOException(e);</span>
<span class="nc" id="L146">        } catch (TimeoutException e){</span>
<span class="nc" id="L147">            throw TimeOutUtils.logAndGenerateExceptionOnTimeOut(logger, &quot;read&quot;,</span>
                    TimeOutUtils.TIMEOUT_TIME_LENGTH_5, TimeUnit.MINUTES);
        }
    }

    private void clearPriorFragments(int currentFragIndx){
<span class="nc" id="L153">        final Set&lt;@NonNull Integer&gt; priorIndexes = readAheadBuffersCache</span>
<span class="nc" id="L154">                .asMap()</span>
<span class="nc" id="L155">                .keySet().stream()</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                .filter(idx -&gt; idx &lt; currentFragIndx)</span>
<span class="nc" id="L157">                .collect(Collectors.toSet());</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        if(priorIndexes.size() &gt; 0) {</span>
<span class="nc" id="L160">            logger.debug(&quot;invalidating fragment(s) '{}' from '{}'&quot;,</span>
<span class="nc" id="L161">                    priorIndexes.stream().map(Objects::toString).collect(Collectors.joining(&quot;, &quot;)), path.toUri());</span>

<span class="nc" id="L163">            readAheadBuffersCache.invalidateAll(priorIndexes);</span>
        }
<span class="nc" id="L165">    }</span>

    @Override
    public boolean isOpen() {
<span class="nc" id="L169">        return open;</span>
    }

    @Override
    public void close() {
<span class="nc" id="L174">        open = false;</span>
<span class="nc" id="L175">        readAheadBuffersCache.invalidateAll();</span>
<span class="nc" id="L176">        readAheadBuffersCache.cleanUp();</span>
<span class="nc" id="L177">    }</span>

    /**
     * The number of fragments currently in the cache.
     * @return the size of the cache after any async evictions or reloads have happened.
     */
    protected int numberOfCachedFragments(){
<span class="nc" id="L184">        readAheadBuffersCache.cleanUp();</span>
<span class="nc" id="L185">        return (int) readAheadBuffersCache.estimatedSize();</span>
    }

    /**
     * Obtain a snapshot of the statistics of the internal cache, provides information about hits, misses, requests, evictions etc.
     * that are useful for tuning.
     * @return the statistics of the internal cache.
     */
    protected CacheStats cacheStatistics(){
<span class="nc" id="L194">        return readAheadBuffersCache.stats();</span>
    }

    private CompletableFuture&lt;ByteBuffer&gt; computeFragmentFuture(int fragmentIndex){
<span class="nc" id="L198">        long readFrom = (long) fragmentIndex * maxFragmentSize;</span>
<span class="nc" id="L199">        long readTo = Math.min(readFrom + maxFragmentSize, size) -1;</span>
<span class="nc" id="L200">        String range = &quot;bytes=&quot; + readFrom + &quot;-&quot; + readTo;</span>
<span class="nc" id="L201">        logger.debug(&quot;byte range for {} is '{}'&quot;, path.getKey(), range);</span>

<span class="nc" id="L203">        return client.getObject(</span>
<span class="nc" id="L204">                    builder -&gt; builder</span>
<span class="nc" id="L205">                        .bucket(path.bucketName())</span>
<span class="nc" id="L206">                        .key(path.getKey())</span>
<span class="nc" id="L207">                        .range(range),</span>
<span class="nc" id="L208">                    AsyncResponseTransformer.toBytes())</span>
<span class="nc" id="L209">                .thenApply(BytesWrapper::asByteBuffer);</span>
    }

    /**
     * Compute which buffer a byte should be in
     * @param byteNumber the number of the byte in the object accessed by this channel
     * @return the index of the fragment in which {@code byteNumber} will be found.
     */
    protected Integer fragmentIndexForByteNumber(long byteNumber){
<span class="nc" id="L218">        return Math.toIntExact(Math.floorDiv(byteNumber, maxFragmentSize));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>